{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://github.com/styvenh/styvenh.github.io","root":"/"},"pages":[{"title":"","date":"2023-10-28T08:26:13.304Z","updated":"2023-10-13T11:39:34.485Z","comments":true,"path":"最大公约数和最小公倍数.html","permalink":"https://github.com/styvenh/styvenh.github.io/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0.html","excerpt":"","text":"[NOIP2001 普及组] 最大公约数和最小公倍数问题题目描述输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数： $P,Q$ 是正整数。 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。 试求：满足条件的所有可能的 $P, Q$ 的个数。 输入格式一行两个正整数 $x_0, y_0$。 输出格式一行一个数，表示求出满足条件的 $P, Q$ 的个数。 样例 #1样例输入 #113 60 样例输出 #114 提示$P,Q$ 有 $4$ 种： $3, 60$。 $15, 12$。 $12, 15$。 $60, 3$。 对于 $100%$ 的数据，$2 \\le x_0, y_0 \\le {10}^5$。 【题目来源】 NOIP 2001 普及组第二题 #思路####1.由最大公约数和最小公倍数的性质可知x&lt;&#x3D;P&#x2F;Q&lt;&#x3D;y####2.两个数的积等于它们最大公约数和它们最小公倍数的积 x×y&#x3D;P×Q gcd(x,y)&#x3D;P（gcd&#x3D;最大公约数） lcm(x,y)&#x3D;Q （lcm&#x3D;最小公倍数） 分别枚举x y,然后判断是否满足以上三条件 &#x2F;&#x2F;超时 优化：对于不同的x,y通过交换它们的值来得到另一组结果，因此只需枚举从1到sqrt(P*Q)，每发现一组结果，num加2. #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; using ll=long long; ll x,y; ll num=0; int gcd(ll a,ll b)&#123; for(ll i=a;i&gt;0;i--)&#123; if(a%i==0&amp;&amp;b%i==0)&#123; return i; &#125; &#125; &#125; int main()&#123; cin&gt;&gt;x&gt;&gt;y; if(x==y)&#123; num-=1; &#125; ll n=x*y; for(ll i=1;i&lt;=sqrt(n);i++)&#123; if(n%i==0&amp;&amp;gcd(i,n/i)==x)&#123; num+=2; &#125; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0; &#125; 当积相同且gcd 相同时，lcm 也一定相同，因此只需判断是否满足一、二两个条件即可。"},{"title":"","date":"2023-10-28T08:26:13.306Z","updated":"2023-10-13T11:39:29.666Z","comments":true,"path":"求先序排序.html","permalink":"https://github.com/styvenh/styvenh.github.io/%E6%B1%82%E5%85%88%E5%BA%8F%E6%8E%92%E5%BA%8F.html","excerpt":"","text":""},{"title":"Hello World","date":"2023-10-28T12:35:06.399Z","updated":"2023-10-28T06:36:01.561Z","comments":true,"path":"hello-world.html","permalink":"https://github.com/styvenh/styvenh.github.io/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"","date":"2023-10-28T08:26:13.308Z","updated":"2023-09-02T04:49:24.519Z","comments":true,"path":"迭代器.html","permalink":"https://github.com/styvenh/styvenh.github.io/%E8%BF%AD%E4%BB%A3%E5%99%A8.html","excerpt":"","text":"迭代器(iterator)功能: 访问容器对象的元素所有标准库容器都可以使用迭代器，其中只有少数几种(vector)才同时支持下标运算符。 string对象不属于容器类型，但是string支持很多与容器类型类似的操作。 迭代器分为有效和无效，这点和指针差不多有效迭代器：指向某个元素，或者指向容器尾元素的下一个位置。 无效迭代器：除有效迭代器之外的其他所有情况。 迭代器的使用迭代器不使用取地址符(与指针区分开)，有迭代器的类型同时拥有返回迭代器的成员，比如begin和end成员。 begin成员：负责返回指向第一个元素(或字符)的迭代器end成员：负责返回指向容器(或string对象)”尾元素的下一个位置(one past the end)”的迭代器。即：该迭代器指示的是容器的一个本不存在的”尾后(off the end)”元素。所以又名：尾(后)迭代器如果容器为空，则begin和end返回相同，都是尾后迭代器。 因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。 C++定义了箭头运算符(-&gt;)，把解引用和成员访问两个操作结合在一起。即it-&gt;mem和(*it).mem表达的意思相同[2]。 迭代器类型无需知道迭代器的精准类型(像string一样) 拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器类型： const_iterator：类似常量指针，只读，不能修改所指元素值 iterator：对其所指元素可读可写 如果对象是常量，只能用const_iterator，否则都能用 begin和end运算符返回的具体类型，由对象是否是常量决定。若是，则返回const_iterator，否则返回iterator。"},{"title":"","date":"2023-10-28T08:26:13.302Z","updated":"2023-10-13T11:39:27.796Z","comments":true,"path":"变进制数(火星人).html","permalink":"https://github.com/styvenh/styvenh.github.io/%E5%8F%98%E8%BF%9B%E5%88%B6%E6%95%B0(%E7%81%AB%E6%98%9F%E4%BA%BA).html","excerpt":"","text":"[NOIP2004 普及组] 火星人题目描述人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。 火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。 一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字： 三进制数 代表的数字 $123$ $1$ $132$ $2$ $213$ $3$ $231$ $4$ $312$ $5$ $321$ $6$ 现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。 输入格式共三行。第一行一个正整数 $N$，表示火星人手指的数目（$1 \\le N \\le 10000$）。第二行是一个正整数 $M$，表示要加上去的小整数（$1 \\le M \\le 100$）。下一行是 $1$ 到 $N$ 这 $N$ 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。 输出格式$N$ 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。 样例 #1样例输入 #1123531 2 3 4 5 样例输出 #111 2 4 5 3 变进制数 #11234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int a[10005];bool used[10005]=&#123;0&#125;;int m,n;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; int x=a[i]; for(int j=1;j&lt;=a[i];j++) x-=used[j]; used[a[i]]=1; a[i]=x-1; &#125; a[n]+=m; for(int i=n;i&gt;0;i--) &#123; a[i-1]+=a[i]/(n-i+1); a[i]%=n-i+1; &#125; memset(used,0,sizeof(used)); for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;=a[i];j++) if(used[j]) a[i]++; cout&lt;&lt;a[i]+1&lt;&lt;&quot; &quot;; used[a[i]]=1; &#125; return 0;&#125;"}],"posts":[],"categories":[],"tags":[]}